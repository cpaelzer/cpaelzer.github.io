<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>libvirt on Pälzer</title>
    <link>https://cpaelzer.github.io/tags/libvirt/</link>
    <description>Recent content in libvirt on Pälzer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Jan 2020 12:08:27 +0200</lastBuildDate><atom:link href="https://cpaelzer.github.io/tags/libvirt/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ubuntu Virtualization Stack Crystal Ball</title>
      <link>https://cpaelzer.github.io/blogs/008-virt-stack-crystal-ball/</link>
      <pubDate>Mon, 20 Jan 2020 12:08:27 +0200</pubDate>
      
      <guid>https://cpaelzer.github.io/blogs/008-virt-stack-crystal-ball/</guid>
      <description>Ubuntu Virtualization Stack Crystal Ball a.k.a which version of QEMU/libvirt will be in the next Ubuntu release? Background I am asked a lot of times in different contexts which version of QEMU, libvirt, or other components the next Ubutuntu release will contain. What this post will address how the upstreams manage versions and then how the Ubuntu project chooses a version to ship.
Upstream First, consider how the two major upstreams of QEMU and libvirt handle versioning.</description>
    </item>
    
    <item>
      <title>Mediated Device GPU passthrough</title>
      <link>https://cpaelzer.github.io/blogs/006-mediated-device-to-pass-parts-of-your-gpu-to-a-guest/</link>
      <pubDate>Wed, 17 Apr 2019 12:08:27 +0200</pubDate>
      
      <guid>https://cpaelzer.github.io/blogs/006-mediated-device-to-pass-parts-of-your-gpu-to-a-guest/</guid>
      <description>Mediated Device based GPU passthrough a.k.a passing part of a whole The many faces and names of vGPU Having GPU resources in the guest has various use cases. From a windows gaming VM to GPGPU assisted AI learning. Due to that there are many things people commonly call a &amp;ldquo;virtual Graphics Processing Unit&amp;rdquo; =&amp;gt; vGPU. Unfortunately it doesn&amp;rsquo;t help at all that many guides, forum posts and blogs call all of them vGPU.</description>
    </item>
    
    <item>
      <title>KVM Guests bigger than 1TiB</title>
      <link>https://cpaelzer.github.io/blogs/005-guests-bigger-than-1tb/</link>
      <pubDate>Wed, 17 Apr 2019 10:08:27 +0200</pubDate>
      
      <guid>https://cpaelzer.github.io/blogs/005-guests-bigger-than-1tb/</guid>
      <description>KVM Guests bigger than 1TiB a.k.a size matters Background addressing memory More memory is almost always good, but to be able to use it it needs to be addressable as well. CPU&amp;rsquo;s are different and you can check yours how many bits are really supported.
$ cat /proc/cpuinfo | grep &amp;#39;^address sizes&amp;#39; ... # an older server with a E5-2620 address sizes : 46 bits physical, 48 bits virtual # a laptop with an i7-8550U address sizes : 39 bits physical, 48 bits virtual And ignoring all other constraints, to address 1TiB you&amp;rsquo;ll need 40 bits, so if you want to have more than 1TiB of guest memory it needs more than 40 bits to address it.</description>
    </item>
    
    <item>
      <title>query and control virtio version</title>
      <link>https://cpaelzer.github.io/blogs/001-qemu-libvirt-virtio-version/</link>
      <pubDate>Wed, 07 Feb 2018 12:51:26 +0100</pubDate>
      
      <guid>https://cpaelzer.github.io/blogs/001-qemu-libvirt-virtio-version/</guid>
      <description>virtio: modern/legacy = ??? a.k.a puzzlement about inquiring or controlling virtio revisions via libvirt When looking around how to check for the current setting of modern/legacy virtio, or how to control it via libvirt I only found dead ends at first.
 If you search how to get some info about it you will find query-virtio/info virtio, but after 5 versions being discussed nothing is merged still. If instead you search how to better control the version you&amp;rsquo;ll find virtio revision, but also 5 versions discussed until declared postponed.</description>
    </item>
    
  </channel>
</rss>
